<!DOCTYPE html>
<html>
<head>
  <title>PCCS</title>
  <link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
  <style type="text/css">
  body {
      background-color: rgba(70,150,200);
      color: white;
      font-family: "Fira Sans", sans-serif;
      font-size: 0.9em;
  }
  textarea {
      width: 49%;
      min-width: 400px;
      height: 500px;
      background-color: black;
      color: white;
      font-family: "Fira Mono", mono;
  }
  </style>
</head>
<body>
  <h1>PCCS</h1>
  Parameterised Calculus of Concurrent Systems (CWB-NC) <br>
  Domain Specific Language
  <p>
    <button id="compile">Compile!</button>
    <button id="example">Load Example</button>
    <button id="hide">&gt;</button>
  </p>
  <div>
    <textarea id="input" spellcheck="false">proc { ProcName, action }</textarea>
    <textarea id="output" spellcheck="false"></textarea>
  </div>
  <script src="fengari-web.js" type="text/javascript"></script>
  <!-- <script type="application/lua"> -->
  <!--   local pccs -->
  <!--   local function newpobj(callf) -->
  <!--   local mt = { -->
  <!--   __bnot=function(a) -->
  <!--   return newpobj(function() -->
  <!--   return  "'" .. a() -->
  <!--   end) -->
  <!--   end, -->
  <!--   __sub=function(a,b) -->
  <!--   return newpobj(function() -->
  <!--   return  '('.. a() .. ' \\ ' .. b() .. ')' -->
  <!--   end) -->
  <!--   end, -->
  <!--   __div=function(a,b) -->
  <!--   return newpobj(function() -->
  <!--   return  a() .. ' / ' .. b() -->
  <!--   end) -->
  <!--   end, -->
  <!--   __bor=function(a,b) -->
  <!--   return newpobj(function() -->
  <!--   return '(' .. a() .. ' | ' .. b() .. ')' -->
  <!--   end) -->
  <!--   end, -->
  <!--   __concat=function(a,b) -->
  <!--   return newpobj(function() -->
  <!--   return '(' .. a() .. ' . ' .. b() .. ')' -->
  <!--   end) -->
  <!--   end, -->
  <!--   __add=function(a,b) -->
  <!--   return newpobj(function() -->
  <!--   return '(' .. a() .. ' + ' .. b() .. ')' -->
  <!--   end) -->
  <!--   end, -->
  <!--   __call=callf -->
  <!--   } -->
  <!--   local t = {__type='pname'} -->
  <!--   return setmetatable(t, mt) -->
  <!--   end -->

  <!--   local function loadsafe(str) -->
  <!--   local t = table.pack(load('return ' .. str, nil, 't', pccs)()) -->
  <!--   for i=1,t.n do -->
  <!--   if type(t[i]) == 'table' then -->
  <!--   t[i] = t[i]() -->
  <!--   end -->
  <!--   end -->
  <!--   return table.unpack(t) -->
  <!--   end -->

  <!--   -- call f with env set by looping over ranges ... (range: {'j', 1, 3}) -->
  <!--   local function rangeswalker(f, ...) -->
  <!--   local nr = select('#', ...) -->
  <!--   if nr == 0 then -->
  <!--   f() -->
  <!--   else -->
  <!--   local r = (...) -->
  <!--   if r[4] then -->
  <!--   for i=r[2],r[3],r[4] do -->
  <!--   pccs[r[1]]=i -->
  <!--   rangeswalker(f, select(2,...)) -->
  <!--   end -->
  <!--   else -->
  <!--   for i=r[2],r[3] do -->
  <!--   pccs[r[1]]=i -->
  <!--   rangeswalker(f, select(2,...)) -->
  <!--   end -->
  <!--   end -->
  <!--   pccs[r[1]]=nil -->
  <!--   end -->
  <!--   end -->

  <!--   local function rangesacc(rf, f, ranges) -->
  <!--   ranges = ranges or {} -->
  <!--   if type(rf) == "string" then -->
  <!--   table.insert(ranges, rf) -->
  <!--   return function(nrf) -->
  <!--   return rangesacc(nrf, f, ranges) -->
  <!--   end -->
  <!--   else -->
  <!--   return f(ranges,rf) -->
  <!--   end -->
  <!--   end -->

  <!--   local function evalrange(range) -->
  <!--   local name, ab = string.match(range, "(.*):(.*)") -->
  <!--   --return {name,   assert(load('return ' .. ab, nil, 't', pccs))()} -->
  <!--   return {name, loadsafe(ab)} -->
  <!--   end -->

  <!--   local function evalranges(ranges) -->
  <!--   for i,v in ipairs(ranges) do -->
  <!--   ranges[i] = evalrange(v) -->
  <!--   end -->
  <!--   end -->

  <!--   local function operator(sym) -->
  <!--   return function (ranges, body) -->
  <!--   if body == nil then error ("Range operator "..sym.." needs at least one argument") end -->
  <!--   if #ranges == 0 then error ("Range operator "..sym.." needs at least one range") end -->
  <!--   return newpobj(function () -->
  <!--   local operands = {} -->
  <!--   local function addoperands() -->
  <!--   table.insert(operands, body[1]()) -->
  <!--   end -->
  <!--   evalranges(ranges) -->
  <!--   rangeswalker(addoperands, table.unpack(ranges)) -->
  <!--   return '('..table.concat(operands, ' ' .. sym .. ' ')..')' -->
  <!--   end) -->
  <!--   end -->
  <!--   end -->


  <!--   local function definition (rf, class) -->
  <!--   local function _def(ranges, body) -->
  <!--   if body == nil then error ("A "..class.." definition needs at least one table argument") end -->
  <!--   if #body ~= 2 then error ("A "..class.." definition requires two arguments in following table") end -->
  <!--   local function adddef() -->
  <!--   table.insert(pccs.__result, class..' '..body[1]()..' = '..body[2]()) -->
  <!--   end -->
  <!--   if ranges and #ranges ~= 0 then -->
  <!--   evalranges(ranges) -->
  <!--   rangeswalker(adddef ,table.unpack(ranges)) -->
  <!--   else -->
  <!--   adddef() -->
  <!--   end -->
  <!--   end -->
  <!--   return rangesacc(rf, _def) -->
  <!--   end -->

  <!--   local function proc(rf) -->
  <!--   return definition(rf, 'proc') -->
  <!--   end -->

  <!--   local function dset(rf) -->
  <!--   return definition(rf, 'set') -->
  <!--   end -->

  <!--   -- return an array with the ranges -->
  <!--   local function getranges(el) -->
  <!--   local j = 1 -->
  <!--   local ranges={} -->
  <!--   while type(el[j]) == "string" do -->
  <!--   table.insert(ranges, el[j]) -->
  <!--   j = j + 1 -->
  <!--   end -->
  <!--   if j ~= #el or j == 1 then error("The first arguments should be string ranges") end -->
  <!--   return ranges -->
  <!--   end -->

  <!--   -- make a list for set and rel -->
  <!--   local function makelist(t) -->
  <!--   local actions={} -->
  <!--   for _, el in ipairs(t) do -->
  <!--   if type(el) == "table" and el.__type ~= "pname" then -->
  <!--   local ranges = getranges(el) -->
  <!--   local function addaction() -->
  <!--   table.insert(actions, el[#el]()) -->
  <!--   end -->
  <!--   evalranges(ranges) -->
  <!--   rangeswalker(addaction ,table.unpack(ranges)) -->
  <!--   else -->
  <!--   table.insert(actions, el()) -->
  <!--   end -->
  <!--   end -->
  <!--   return table.concat(actions, ', ') -->

  <!--   end -->

  <!--   local function set(t) -->
  <!--   if type(t) ~= 'table' then error("Set requires a table argument in first position") end -->
  <!--   return newpobj(function() -->
  <!--   return '{'..makelist(t)..'}' -->
  <!--   end) -->
  <!--   end -->

  <!--   local function rel(t) -->
  <!--   if type(t) ~= 'table' then error("Rel requires a table argument in first position") end -->
  <!--   if #t < 2 then error("Rel requires as input a table containing at least two elements") end -->
  <!--           local name = table.remove(t,1) -->
  <!--           if name.__type ~= "pname" then error("First argument must be a name") end -->
  <!--           return newpobj(function() -->
  <!--           return '('..name()..'['..makelist(t)..'])' -->
  <!--           end) -->
  <!--           end -->

  <!--           local function sum(rf) -->
  <!--           return rangesacc(rf, operator('+')) -->
  <!--           end -->

  <!--           local function pre(rf) -->
  <!--           return rangesacc(rf, operator('.')) -->
  <!--           end -->

  <!--           local function par(rf) -->
  <!--           return rangesacc(rf, operator('|')) -->
  <!--           end -->

  <!--           local function refreshenv() -->
  <!--           pccs = {} -->
  <!--           pccs.__result = {} -->
  <!--           pccs.proc = proc -->
  <!--           pccs.dset = dset -->
  <!--           pccs.set = set -->
  <!--           pccs.rel = rel -->
  <!--           pccs.sum = sum -->
  <!--           pccs.pre = pre -->
  <!--           pccs.par = par -->
  <!--           setmetatable(pccs, {__index = function(self, key) -->
  <!--           return newpobj( -->
  <!--           function(_, str) -->
  <!--           if type(str) == "string" then -->
  <!--           return newpobj(function() -->
  <!--           return table.concat({key, loadsafe(str)}, '_') -->
  <!--           end) -->
  <!--           else -->
  <!--           return key -->
  <!--           end -->
  <!--           end) -->
  <!--           end}) -->
  <!--           end -->

  <!--           function compile(str) -->
  <!--           refreshenv() -->
  <!--           load(str, nil, "t", pccs)() -->
  <!--           return table.concat(pccs.__result, '\n') -->
  <!--           end -->
  <!--           </script> -->

  <script src="pccs.lua" type="application/lua"></script>
  <script type="application/lua">
    js = require "js"
    document = js.global.document
    local button = document:getElementById("compile")
    local hidebtn = document:getElementById("hide")
    local input = document:getElementById("input")
    local output = document:getElementById("output")
    local example = document:getElementById("example")
    function comp()
    ok, outerr  = pcall(compile, input.value)
    output.value = outerr
    end
    button:addEventListener("click", comp)

    local pipesrc = [[
-- -*- mode: lua -*-
-- Implementation of the PIPE Buffer

ncel = 3
nsym = 2

--  Basic Cell Agent
proc { LB 'C' , sum 'i:1,nsym' {inn 'i' .. ~out 'i' .. LB 'C' }}

-- Relabaling for Buffer Out

proc { LB 'C,ncel+1', rel { LB 'C', {'i:1,nsym', d 'ncel,i' / out 'i'} } }

-- Relabaling for Buffer In
proc { LB 'C,0', rel { LB_C, {'i:1,nsym', d '0,i' / inn 'i'} } }

-- Relabaling for Central Cells

proc 'i:1,ncel' {LB 'C,i', rel { LB 'C',
                                 {'s:1,nsym', d 'i,s' / inn 's' },
                                 {'s:1,nsym', d 'i-1,s' / out 's' }
                               }
                }

-- Put all in parallel

dset { Internals, set {{'s:1,nsym', 'i:0,ncel', d 'i,s'}} }

proc { LB, par 'i:0,ncel+1' {LB 'C,i'} - Internals }

    ]]

    example:addEventListener("click", function() input.value = pipesrc end)
    local outvis = true
    hidebtn:addEventListener("click", function()
                             if outvis then
                             -- output.style.display = 'none'
                             input.style.width = '98%'
                             output.style.width = '98%'
                             hidebtn.textContent = '<'
                             outvis = false
                             else
                             -- output.style.display = 'inline'
                             input.style.width = '49%'
                             output.style.width = '49%'
                             hidebtn.textContent = '>'
                             outvis = true
                             end
                             end)
  </script>
PCCS is distributed under an MIT License.
</body>
</html>
